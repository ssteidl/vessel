#! /usr/bin/env tclsh8.6
# -*- mode: tcl; indent-tabs-mode: nil; tab-width: 4; -*-

package require cmdline
package require inifile

package require vessel::native
package require vessel::deploy
package require vessel::metadata_db
package require vessel::syslog
package require dicttool

package require logger


set log [logger::init vessel]
logger::setlevel info

proc bgerror {message} {
    global errorInfo
    global errorCode
    global log

    ${log}::error "bgerror: $message, $errorInfo, $errorCode"
}

namespace eval vessel::supervisor {

    namespace eval mc {
        namespace ensemble create
        namespace export container_key \
            get_deploy_dict \
            get_container_name \
            get_coro_name \
            is_monitored \
            monitor_container \
            add_ctrl_channel \
            ctrl_channel


        #Array of containers that we are monitoring
        variable _containers
        array set _containers {}

        proc container_key {deploy_file} {
            return [file tail [file rootname ${deploy_file}]]
        }


        proc get_deploy_dict {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            if {[info exists _containers($key)]} {
                return _containers("$key,ini")
            }

            set deploy_dict [vessel::deploy::ini::get_deployment_dict $deploy_file]
            set _containers("$key,ini") $deploy_dict
            return $deploy_dict
        }

        proc get_container_name {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            set deploy_dict [get_deploy_dict $deploy_file]

            set container_name [dict getnull $deploy_dict vessel-supervisor name]
            if {$container_name eq {}} {
                set container_name $key
            }

            return $container_name
        }

        proc get_coro_name {deploy_file} {

            return "monitor-[container_key $deploy_file]"            
        }

        proc is_monitored {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            return [info exists _containers("$key,coro")]
        }

        proc monitor_container {deploy_file} {
            variable _containers

            if {[is_monitored $deploy_file]} {
                error "The container is already being monitored: [get_container_name $deploy_file]"
            }

            return [get_deploy_dict $deploy_file]
        }

        proc add_ctrl_channel {deploy_file ctrl_chan} {
            variable _containers
            set key [container_key $deploy_file]

            set _containers("$key,ctrlchan") $ctrl_chan
        }

        proc ctrl_channel {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]

            if {[is_monitored $deploy_file]} {
                error "Attempted to retrieve control channel for unmonitored container"
            }

            if {![info exists _containers("$key,ctrlchan")]} {
                error "Attempted to retrieve control channel on monitored container before it is set: $key"
            }

            return _containers("$key,ctrlchan")
        }
    }

    # Monitors the ctrl_channel for messages from a given container.
    proc msg_loop_coro {container_name ctrl_channel msg_callback exit_callback} {
        global log

        ${log}::debug "Configuring run_loop($ctrl_channel)"
        chan configure $ctrl_channel -blocking false -buffering none

        chan event $ctrl_channel readable [list [info coroutine] "ctrl_read"]

        while {true} {
            
            #Yield until an event is received
            set event_type [yield]

            switch -exact $event_type {
                "ctrl_read" {
                    #NOTE: Currently we don't expect any messages but we can in the future.
                    set msg {}
                    gets $ctrl_channel msg
                    if {[eof $ctrl_channel]} {
                        #ctrl_channel closed.  Assume the process exited.
                        close $ctrl_channel
                        ${log}::debug "Closed ctrl_channel($container_name)"

                        if {$exit_callback ne {}} {                        
                            after idle [list {*}$exit_callback "ctrl_closed"]
                        }
                        break
                    } elseif {![fblocked $ctrl_channel]} {
                        if {$msg_callback ne {}} {
                            after idle [list {*}$msg_callback "ctrl_msg" $msg]
                        }
                    }
                }
                default {
                    ${log}::warn "Unknown event received for run loop($container_name): $event_type"
                }
            }
        } 

        ${log}::debug "Exiting run_loop($container_name)"
    }

    #Start a container by using the vessel::exec procedure to setup and invoke
    #vessel.  All of the exec lifecycle events will be sent to the callback_coro
    proc start_container {deploy_file_path image tag callback_coro} {

        set deploy_dict [mc get_deploy_dict $deploy_file_path]
        set command [dict get $deploy_dict vessel-supervisor command]

        set jail_name [mc get_container_name $deploy_file_path]
        #NOTE: We might want to implement a detach or keep-attached option.  The difference
        #is really signal processing when running the supervisor in the foreground.
        set vessel_cmd "vessel run --name=${jail_name} --ini=${deploy_file_path} ${image}:${tag}"
        lappend vessel_cmd {*}$command
        puts stderr "$vessel_cmd"

        # standard out and standard in to files or other channels
        set pipe_list [chan pipe]
        set read_side [lindex $pipe_list 0]
        set write_side [lindex $pipe_list 1]
        set chan_dict [dict create stdin stdin stdout $write_side stderr $write_side]

        dict set monitored_containers_dict $jail_name $deploy_dict

        # Execute the vessel command.  vessel::exec will send lifecycle events to the
        # coroutine.
        vessel::exec $chan_dict [list {*}$callback_coro $jail_name $read_side] {*}${vessel_cmd}
        
        #The child process has been forked.  We can close the write side.
        close $write_side
    }

    #Handle the container started event by configuring the ctrl channel
    #provided in the event and starting the msg_loop coroutine for the container.
    proc container_started {event} {
        #Expected Event format as configured from start_container: 
        # <jail_name> <read_pipe> start <ctrl_pipe>

        if {[llength $event] < 4 || [lindex $event end-1] ne "start"} {
            error "Unexpected event while waiting for container to start: $event"
        }
        set ctrl_channel [lindex $event end]
        set jail_name [lindex $event 0]
        
        set child_stdout [lindex $event 1]
        chan configure $child_stdout -blocking 0 -buffering none -translation binary
        fileevent $child_stdout readable [list apply {{child_stdout} {
            puts stderr "data ready"
            set data [read $child_stdout]
            if {[eof $child_stdout]} {
                    
                close $child_stdout
            } else {
                puts -nonewline stderr "CHILD DATA: $data"
            }
	    }} $child_stdout]

        # TODO: The name needs to come from the mc ensemble
        coroutine "msg_loop_$jail_name" msg_loop_coro $jail_name $ctrl_channel [info coroutine] {}
        return $ctrl_channel
    }

    #The main event processing coroutine for a container.
    proc container_coro {deploy_file main_coro} {
        global log
        variable monitored_containers_dict

        set container_name [mc get_container_name $deploy_file]
        ${log}::debug "starting container: $container_name"
        set deploy_dict [mc get_deploy_dict $deploy_file]
        puts stderr $deploy_dict
        set image [dict get $deploy_dict vessel-supervisor image]
        set tag [dict get $deploy_dict vessel-supervisor tag]

        #initialization yield
        yield
        
        if {![vessel::metadata_db::image_exists $image $tag]} {

            #Image doesn't exist.  We need to pull it from the repository
            return -code error -errorcode {SUPERVISOR PULL NYI} "Supervisor pull NYI"
        }

        set container_started_event [yieldto start_container $deploy_file $image $tag  [info coroutine]]

        ${log}::debug "Container started event: $container_started_event"

        set ctrl_channel [container_started $container_started_event]

        set restart false
        set exited false
        #container monitoring event loop
        while {true} {

            #Wait for next event
            set event_args [yieldto return -level 0]
            if {[llength $event_args] < 1} {
                ${log}::warn "Event with no event_type received"
                continue
            }      
            set event_type [lindex $event_args end]
            ${log}::debug "eventargs: $event_args"
            switch -exact $event_type {
                
                "ctrl_msg" {
                    set msg [lindex $event_args 1]
                    ${log}::debug "control message received: $msg"
                }
                "ctrl_closed" {
                    ${log}::debug "Unexpected ctrl_closed found"
                }
                "stop_requested" {
                    puts $ctrl_channel "stop"
                }
                "restart_requested" {
                    puts $ctrl_channel "stop"
                    set restart true
                }
                "exit" {
                    set exited true
                }
                default {
                    ${log}::warn "Unexpected event when monitoring container: $event_args"
                }
            }
            if {$exited} {
                break
            }
        }

        ${log}::info "$container_name finished executing.  Cleaning up..."

        if {$restart} {
            ${log}::info "Restarting($container_name)"
            after idle [list [namespace current]::poll_start $deploy_file]
        } else {
            ${log}::debug "No restart requested"
        }
    }

    # Periodically poll the deployment dir
    # and apply the changes to the managed containers.  
    # Start, Stop or Restart the containers.
    proc poll_deploy_dir {_deploy_dir event_callback} {
        
        # The path must be normalized when calling deploy::deploy_dir
        set deploy_dir [file normalize $_deploy_dir]

        set changed_dict [vessel::deploy::poll_deploy_dir $deploy_dir]

        #Queue up the containers that need to be 
        foreach deploy_file [dict getnull $changed_dict "start"] {
            #TODO: make a queue or figure out how to do this synchronously (probably another coroutine).  We don't
            #want to be starting some containers while the same container is still starting.
            #There needs to be some safe guards in place.

            after idle [list {*}$event_callback poll_start $deploy_file]
        }

        foreach deploy_file [dict getnull $changed_dict "stop"] {
            after idle [list {*}$event_callback poll_stop $deploy_file]
        }

        foreach deploy_file [dict getnull $changed_dict "modified"] {
            after idle [list {*}$event_callback poll_modified $deploy_file]
        }
    }


    # Creates a container monitoring coroutine
    proc poll_start {deploy_file} {

        set container_coro_name [mc get_coro_name $deploy_file]
        coroutine  $container_coro_name container_coro $deploy_file [info coroutine]
        after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
    }

    proc poll_stop {deploy_file} {

        set coro_name [mc get_coro_name $deploy_file]
        $coro_name "stop_requested"
    }

    proc poll_modified {deploy_file} {

        set coro_name [mc get_coro_name $deploy_file]
        $coro_name "restart_requested"
    }

    proc poll_timer {deploy_dir} {
        after idle [list vessel::supervisor::poll_deploy_dir $deploy_dir [info coroutine]]
    }

    proc start_poll_timer {deploy_dir} {
        after 2000 [list [info coroutine] poll_timer $deploy_dir]
    }

    #Highest level coroutine, manages the polling of the deployment directory.
    proc main_event_loop_coro {deploy_dir} {
        global log


        #Initialization yield
        yield

        while {true} {
            start_poll_timer $deploy_dir
            
            set event_args [yieldto return -level 0]
            if {[llength $event_args] <= 0} {
                ${log}::debug "Ignoring event without event type"
                continue
            }

            #Add the main coroutine so sub-coroutines can generate events on the main coroutine
            switch -exact [lindex $event_args 0] {

                "poll_timer" -
                "poll_start" -
                "poll_stop" -
                "poll_modified" {
                    {*}$event_args
                }

                default {
                    ${log}::debug "Unexpected event type: $event_args"
                }
            }
        }
    }
}


set options {
    {d.arg "/usr/local/etc/vessel/configs"   "deployment file directory to monitor"}
    {debug}
    {syslog}
}
set usage ":  \[options] filename ...\noptions:"

try {
    array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    
    # Trap the usage signal, print the message, and exit the application.
    # Note: Other errors are not caught and passed through to higher levels!
    puts stderr $msg
    exit 1
}

set deploy_dir $params(d)

if {$params(debug)} {
    logger::setlevel debug
}

if {$params(syslog)} {
    vessel::syslog::enable
}

coroutine vessel::supervisor::main_event_loop vessel::supervisor::main_event_loop_coro $deploy_dir
after idle vessel::supervisor::main_event_loop

set running true
vwait running
