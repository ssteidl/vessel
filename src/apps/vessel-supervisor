#! /usr/bin/env tclsh8.6
# -*- mode: tcl; indent-tabs-mode: nil; tab-width: 4; -*-

package require cmdline
package require inifile

package require vessel::native
package require vessel::deploy
package require vessel::metadata_db
package require dicttool

proc bgerror {message} {
    global errorInfo
    global errorCode
    puts "bgerror: $message, $errorInfo, $errorCode"
}

namespace eval vessel::supervisor {

    namespace eval mc {
        namespace ensemble create
        namespace export container_key \
            get_deploy_dict \
            get_container_name \
            get_coro_name \
            is_monitored \
            monitor_container \
            add_ctrl_channel \
            ctrl_channel


        #Array of containers that we are monitoring
        variable _containers
        array set _containers {}

        proc container_key {deploy_file} {
            return [file tail [file rootname ${deploy_file}]]
        }


        proc get_deploy_dict {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            if {[info exists _containers($key)]} {
                return _containers("$key,ini")
            }

            set deploy_dict [vessel::deploy::ini::get_deployment_dict $deploy_file]
            set _containers("$key,ini") $deploy_dict
            return $deploy_dict
        }

        proc get_container_name {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            set deploy_dict [get_deploy_dict $deploy_file]

            set container_name [dict getnull $deploy_dict vessel-supervisor name]
            if {$container_name eq {}} {
                set container_name $key
            }

            return $container_name
        }

        proc get_coro_name {deploy_file} {

            return "monitor-[get_container_name $deploy_file]"            
        }

        proc is_monitored {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]
            return [info exists _containers("$key,coro")]
        }

        proc monitor_container {deploy_file} {
            variable _containers

            if {[is_monitored $deploy_file]} {
                error "The container is already being monitored: [get_container_name $deploy_file]"
            }

            return [get_deploy_dict $deploy_file]
        }

        proc add_ctrl_channel {deploy_file ctrl_chan} {
            variable _containers
            set key [container_key $deploy_file]

            set _containers("$key,ctrlchan") $ctrl_chan
        }

        proc ctrl_channel {deploy_file} {
            variable _containers
            set key [container_key $deploy_file]

            if {[is_monitored $deploy_file]} {
                error "Attempted to retrieve control channel for unmonitored container"
            }

            if {![info exists _containers("$key,ctrlchan")]} {
                error "Attempted to retrieve control channel on monitored container before it is set: $key"
            }

            return _containers("$key,ctrlchan")
        }
    }


    proc msg_loop_coro {container_name ctrl_channel msg_callback exit_callback} {
        # Monitors the ctrl_channel for a specific container.

        puts stderr "Configuring run_loop($ctrl_channel)"
        chan configure $ctrl_channel -blocking false -buffering none

        chan event $ctrl_channel readable [list [info coroutine] "ctrl_read"]

        while {true} {
            
            #Yield until an event is received
            set event_type [yield]

            switch -exact $event_type {
                "ctrl_read" {
                    #NOTE: Currently we don't process any messages but we can in the future.
                    set msg {}
                    gets $ctrl_channel msg
                    if {[eof $ctrl_channel]} {
                        #ctrl_channel closed.  Assume the process exited.
                        close $ctrl_channel
                        puts stderr "Closed ctrl_channel($container_name)"

                        if {$exit_callback ne {}} {                        
                            after idle [list {*}$exit_callback "ctrl_closed"]
                        }
                        break
                    } elseif {![fblocked $ctrl_channel]} {
                        if {$msg_callback ne {}} {
                            after idle [list {*}$msg_callback "ctrl_msg" $msg]
                        }
                    }
                }
                default {
                    puts stderr "Unknown event received for run loop($container_name): $event_type"
                }
            }
        } 

        puts stderr "Exiting run_loop($container_name)"
    }

    proc start_container {deploy_file_path image tag callback_coro} {

        set deploy_dict [mc get_deploy_dict $deploy_file_path]
        set command [dict get $deploy_dict vessel-supervisor command]

        set jail_name [mc get_container_name $deploy_file_path]
        #NOTE: We might want to implement a detach or keep-attached option.  The difference
        #is really signal processing when running the supervisor in the foreground.
        set vessel_cmd "daemon vessel run --name=${jail_name} --ini=${deploy_file_path} ${image}:${tag}"
        lappend vessel_cmd {*}$command
        puts stderr "$vessel_cmd"

        # TODO: We need to support piping
        # standard out and standard in to files or other channels
        set chan_dict [dict create stdin stdin stdout stdout stderr stderr]

        dict set monitored_containers_dict $jail_name $deploy_dict

        # Execute the vessel command.  vessel::exec will send lifecycle events to the
        # coroutine.
        vessel::exec $chan_dict [list {*}$callback_coro $jail_name] {*}${vessel_cmd}
    }

    proc container_started {event} {
        if {[llength $event] < 3 || [lindex $event 1] ne "start"} {
            error "Unexpected event while waiting for container to start: $event"
        }
        set ctrl_channel [lindex $event 2]
        set jail_name [lindex $event 0]
        
        # TODO: The name needs to come from the mc ensemble
        coroutine "msg_loop_$jail_name" msg_loop_coro $jail_name $ctrl_channel [info coroutine] {}
        return $ctrl_channel
    }

    proc container_coro {deploy_file main_coro} {
        
        variable monitored_containers_dict

        puts stderr "starting container: $deploy_file"
        set deploy_dict [mc get_deploy_dict $deploy_file]
        puts stderr $deploy_dict
        set image [dict get $deploy_dict vessel-supervisor image]
        set tag [dict get $deploy_dict vessel-supervisor tag]

        #initialization yield
        yield
        
        if {![vessel::metadata_db::image_exists $image $tag]} {

            #Image doesn't exist.  We need to pull it from the repository
            return -code error -errorcode {SUPERVISOR PULL NYI} "Supervisor pull NYI"
        }

        #TODO: Fix up this loop.  Validate the start event callback and finish implementation
        # Execute the vessel command which calls back this coroutine at various stages.
        set container_started_event [yieldto start_container $deploy_file $image $tag  [info coroutine]]
        set ctrl_channel [container_started $container_started_event]

        #container monitoring event loop
        while {true} {
            set event_args [yieldto return -level 0]
            if {[llength $event_args] < 1} {
                puts stderr "Event with no event_type received"
                continue
            }      
            set event_type [lindex $event_args 0]
            puts stderr "eventargs: $event_args"
            switch -exact $event_type {
                
                "ctrl_msg" {
                    set msg [lindex $event_args 1]
                    puts stderr "control message received: $msg"
                }
                "ctrl_closed" {
                    puts stderr "Unexpected ctrl_closed found"
                }
                "stop_requested" {
                    puts $ctrl_channel "stop"
                }
                default {
                    puts stderr "Unexpected event when monitoring container: $event_args"
                }
            }
        }
        #TODO: The jail 'name' should be read and set from the supervisor.  then
        # it has a good way of finding and managing the jails.  If name is not provided
        # then use the basename of the file.
        puts stderr "Container finished executing.  Cleaning up..."

        #TODO: Handle restart
    }

    proc shutdown_container_coro {deploy_file} {

        #TODO: Create an ensemble to manage the monitored_containers_dict.
        # We should be able to get the deploy_dict given the deploy file from
        # this ensemble.
        yield
    }

    proc poll_deploy_dir {_deploy_dir event_callback} {
        # Periodically poll the deployment dir
        # and apply the changes to the managed containers.  
        # Start, Stop or Restart the containers.

        # The path must be normalized when calling deploy::deploy_dir
        set deploy_dir [file normalize $_deploy_dir]

        set changed_dict [vessel::deploy::poll_deploy_dir $deploy_dir]

        #puts stderr "changed dict: $changed_dict"
        
        #TODO: I think we need to have a coroutine per deploy file and a list of actions
        # to take.  Actions are either, start, stop or stop,start

        #Queue up the containers that need to be 
        foreach deploy_file [dict getnull $changed_dict "start"] {
            #TODO: make a queue or figure out how to do this synchronously (probably another coroutine).  We don't
            #want to be starting some containers while the same container is still starting.
            #There needs to be some safe guards in place.

            after idle [list {*}$event_callback poll_start $deploy_file]
        }

        #Note I think this needs to go first and have an event that occurs when it has stopped everything it needs to
        foreach deploy_file [dict getnull $changed_dict "stop"] {
            
            set container_coro_name "stop-[file tail [file rootname ${deploy_file}]]"
            coroutine  $container_coro_name stop_container_coro $deploy_file
            after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
        }

        foreach deploy_file [dict getnull $changed_dict "modified"] {
            puts stderr "modified: $deploy_file"
        }
    }

    proc poll_start {deploy_file} {
        # Creates a container monitoring coroutine

        set container_coro_name [mc get_coro_name $deploy_file]
        coroutine  $container_coro_name container_coro $deploy_file [info coroutine]
        after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
    }

    proc poll_stop {deploy_file} {

        #TODO: Get coroutine name and send stop message
    }

    proc poll_timer {deploy_dir} {
        after idle [list vessel::supervisor::poll_deploy_dir $deploy_dir [info coroutine]]
    }

    proc start_poll_timer {deploy_dir} {
        after 2000 [list [info coroutine] poll_timer $deploy_dir]
    }

    proc main_event_loop_coro {deploy_dir} {

        #Initialization yield
        yield

        while {true} {
            start_poll_timer $deploy_dir
            
            set event_args [yieldto return -level 0]
            if {[llength $event_args] <= 0} {
                puts stderr "Ignoring event without event type"
                continue
            }

            #Add the main coroutine so sub-coroutines can generate events on the main coroutine
            switch -exact [lindex $event_args 0] {

                "poll_timer" -
                "poll_start" -
                "poll_stop" {
                    {*}$event_args
                }

                default {
                    puts stderr "Unexpected event type: $event_args"
                }
            }
        }
    }
}


set options {
    {d.arg "/usr/local/etc/vessel/configs"   "deployment file directory to monitor"}
}
set usage ":  \[options] filename ...\noptions:"

try {
    array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    
    # Trap the usage signal, print the message, and exit the application.
    # Note: Other errors are not caught and passed through to higher levels!
    puts stderr $msg
    exit 1
}

parray params

set deploy_dir $params(d)

coroutine vessel::supervisor::main_event_loop vessel::supervisor::main_event_loop_coro $deploy_dir
after idle vessel::supervisor::main_event_loop

set running true
vwait running
