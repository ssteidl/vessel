#! /usr/bin/env tclsh8.6
# -*- mode: tcl; indent-tabs-mode: nil; tab-width: 4; -*-

package require cmdline
package require inifile

package require vessel::native
package require vessel::deploy
package require vessel::metadata_db
package require dicttool

proc bgerror {message} {
    puts "bgerror: $message"
}

namespace eval vessel::supervisor {

    #Dictionary of containers that we are monitoring
    variable monitored_containers_dict [dict create]
    
    proc start_container_coro {deploy_file} {

        puts stderr "starting container"
        set deploy_dict [vessel::deploy::ini::get_deployment_dict $deploy_file]

        puts $deploy_dict
        set image [dict get $deploy_dict vessel-supervisor image]
        set tag [dict get $deploy_dict vessel-supervisor tag]

        #initialization yield
        yield
        
        if {![vessel::metadata_db::image_exists $image $tag]} {

            #Image doesn't exist.  We need to pull it from the repository
            return -code error -errorcode {SUPERVISOR PULL NYI} "Supervisor pull NYI"
        }

        #TODO: We should make vessel communicate with the supervisor with whatever
        #info is needed.  We can create a new pipe for that with an environment
        #variable to specify the descriptor maybe.
        set command [dict get $deploy_dict vessel-supervisor command]

        #TODO: Name should be mandatory
        set jail_name [dict get $deploy_dict vessel-supervisor name]
        set vessel_cmd "vessel run --name=${jail_name} --ini=${deploy_file} ${image}:${tag}"
        lappend vessel_cmd {*}$command
        puts "$vessel_cmd"
        set chan_dict [dict create stdin stdin stdout stdout stderr stderr]

        # Execute the vessel command which calls back this coroutine when it is done
        vessel::exec $chan_dict [info coroutine] {*}${vessel_cmd}

        #Yield until the command finishes
        # NOTE: We should return the exit code as well
        yield

        #TODO: The jail 'name' should be read and set from the supervisor.  then
        # it has a good way of finding and managing the jails
        puts "Container finished executing.  Cleaning up..."

        #TODO: Handle restart
    }

    proc shutdown_container_coro {} {

        yield        
    }

    proc poll_deploy_dir {deploy_dir} {

        defer::defer after 2000 [namespace current]::poll_deploy_dir $deploy_dir

        set changed_dict [vessel::deploy::poll_deploy_dir $deploy_dir]

        puts stderr "changed dict: $changed_dict"
        #Queue up the containers that need to be 
        foreach deploy_file [dict getnull $changed_dict "start"] {
            #TODO: make a queue or figure out how to do this synchronously.  We don't
            #want to be starting some containers while the same container is still starting.
            #There needs to be some safe guards in place.


            set container_coro_name [file tail [file rootname ${deploy_file}]]
            coroutine  $container_coro_name start_container_coro $deploy_file
            after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
        }

        foreach deploy_file [dict getnull $changed_dict "stop"] {
            puts stderr "Stop2: $deploy_file"
        }

        foreach deploy_file [dict getnull $changed_dict "modified"] {
            puts stderr "modified: $deploy_file"
        }
    }
}


set options {
    {d.arg "/usr/local/etc/vessel/configs"   "deployment file directory to monitor"}
}
set usage ":  \[options] filename ...\noptions:"

try {
    array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    
    # Trap the usage signal, print the message, and exit the application.
    # Note: Other errors are not caught and passed through to higher levels!
    puts stderr $msg
    exit 1
}

parray params

set deploy_dir $params(d)

after idle [list vessel::supervisor::poll_deploy_dir $deploy_dir]

set running true
vwait  running
