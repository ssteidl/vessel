#! /usr/bin/env tclsh8.6
# -*- mode: tcl; indent-tabs-mode: nil; tab-width: 4; -*-

package require cmdline
package require inifile

package require vessel::native
package require vessel::deploy
package require vessel::metadata_db
package require dicttool

proc bgerror {message} {
    puts "bgerror: $message"
}

namespace eval vessel::supervisor {

    #Dictionary of containers that we are monitoring
    variable monitored_containers_dict [dict create]
    
    proc start_container_coro {deploy_file} {
        variable monitored_containers_dict

        puts stderr "starting container: $deploy_file"
        set deploy_dict [vessel::deploy::ini::get_deployment_dict $deploy_file]

        puts stderr $deploy_dict
        set image [dict get $deploy_dict vessel-supervisor image]
        set tag [dict get $deploy_dict vessel-supervisor tag]

        #initialization yield
        yield
        
        if {![vessel::metadata_db::image_exists $image $tag]} {

            #Image doesn't exist.  We need to pull it from the repository
            return -code error -errorcode {SUPERVISOR PULL NYI} "Supervisor pull NYI"
        }

        set command [dict get $deploy_dict vessel-supervisor command]

        # TODO: Name should be mandatory
        set jail_name [dict get $deploy_dict vessel-supervisor name]
        set vessel_cmd "vessel run --name=${jail_name} --ini=${deploy_file} ${image}:${tag}"
        lappend vessel_cmd {*}$command
        puts stderr "$vessel_cmd"
        set chan_dict [dict create stdin stdin stdout stdout stderr stderr]


        dict set monitored_containers_dict $jail_name $deploy_dict

        # Execute the vessel command which calls back this coroutine when it is done
        puts "coroutine [info coroutine]"
        set ret [yieldto vessel::exec $chan_dict [info coroutine] {*}${vessel_cmd}]
        puts "ret: $ret"
        #Yield until the command finishes
        # NOTE: We should return the exit code as well
        yield

        #TODO: The jail 'name' should be read and set from the supervisor.  then
        # it has a good way of finding and managing the jails
        puts stderr "Container finished executing.  Cleaning up..."

        #TODO: Handle restart
    }

    proc shutdown_container_coro {deploy_file} {


        puts stderr "stopping container: $deploy_file"
        set deploy_dict [vessel::deploy::ini::get_deployment_dict $deploy_file]

        puts stderr $deploy_dict
        set jail_name [dict get $deploy_dict vessel-supervisor image]
    }

    proc poll_deploy_dir {_deploy_dir} {
        # Periodically poll the deployment dir
        # and apply the changes to the managed containers.  
        # Start, Stop or Restart the containers.

        # The path must be normalized when calling deploy::deploy_dir
        set deploy_dir [file normalize $_deploy_dir]

        # The next poll will be 2 seconds after this coroutine exits.
        defer::defer after 2000 [namespace current]::poll_deploy_dir $deploy_dir

        set changed_dict [vessel::deploy::poll_deploy_dir $deploy_dir]

        puts stderr "changed dict: $changed_dict"
        
        #Queue up the containers that need to be 
        foreach deploy_file [dict getnull $changed_dict "start"] {
            #TODO: make a queue or figure out how to do this synchronously.  We don't
            #want to be starting some containers while the same container is still starting.
            #There needs to be some safe guards in place.

            set container_coro_name "start-[file tail [file rootname ${deploy_file}]]"
            coroutine  $container_coro_name start_container_coro $deploy_file
            after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
        }

        #TODO: We need to send a message via pipe for stop and modify.
        #This is because shutdown needs to happen from inside of the process.
        #Modify should be a stop within the process and when the process exits
        #(the pipe closes) then we'll start it again.
        #
        # Create a command that returns pipe file descriptors and a channel
        # can be created that integrates with kqueue.  We should be able to 
        # set a callback when the read side has closed.  Or we could just note
        # when the vessel process closes.
        foreach deploy_file [dict getnull $changed_dict "stop"] {
            
            set container_coro_name "stop-[file tail [file rootname ${deploy_file}]]"
            coroutine  $container_coro_name stop_container_coro $deploy_file
            after idle [list vessel::supervisor::$container_coro_name ${deploy_file}]
        }

        foreach deploy_file [dict getnull $changed_dict "modified"] {
            puts stderr "modified: $deploy_file"
        }
    }
}


set options {
    {d.arg "/usr/local/etc/vessel/configs"   "deployment file directory to monitor"}
}
set usage ":  \[options] filename ...\noptions:"

try {
    array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    
    # Trap the usage signal, print the message, and exit the application.
    # Note: Other errors are not caught and passed through to higher levels!
    puts stderr $msg
    exit 1
}

parray params

set deploy_dir $params(d)

after idle [list vessel::supervisor::poll_deploy_dir $deploy_dir]

set running true
vwait  running
